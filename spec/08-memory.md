# Memory Model

Kei's memory model provides deterministic resource management without garbage collection through a two-tier approach: all types live on the stack with compiler-managed lifecycle hooks for cleanup and copying.

## Overview

Kei achieves memory safety and performance through:
- **No garbage collector runtime** — all cleanup is compile-time determined
- **Lifecycle hooks** (`__destroy`/`__oncopy`) for deterministic resource management
- **Stack-first design** — all structs live on the stack, heap usage is explicit
- **Compiler auto-generation** of lifecycle hooks for `struct` types
- **Copy-on-Write** for standard library types like `string` and `array<T>`

## Stack allocation (default)

All types in Kei are stack-allocated. Primitives, structs, and even types that manage heap resources (like `string`) have their struct data on the stack:

```kei
fn example() {
    let x = 42;                             // stack - integer
    let p = Point{ x: 1.0, y: 2.0 };      // stack - value struct
    let arr = [1, 2, 3, 4, 5];            // stack - fixed-size array
    let name = "hello";                     // stack - string struct (buffer on heap)
}   // __destroy called on all variables (no-op for primitives and Point)
```

**Characteristics:**
- **Allocation:** Stack frame for struct data
- **Assignment:** Copy + `__oncopy` call
- **Cleanup:** `__destroy` at scope exit (no-op when all fields are primitives)
- **Performance:** Optimal for primitive-only structs — equivalent to C

## Lifecycle hooks

Every type in Kei has two lifecycle hooks: `__destroy` and `__oncopy`. For `struct` types, these are auto-generated by the compiler. For `unsafe struct` types, they are user-defined.

### `__destroy` — Called when a value ceases to exist

```kei
fn example() {
    let user = User{ name: "Alice", age: 25 };
    // ...
} // __destroy(user) called here
  //   -> user.name.__destroy()   (string refcount--)
  //   -> user.age — no-op
```

`__destroy` is called:
- When a variable goes out of scope
- When a field is overwritten by assignment
- When the old value is replaced in an array element

### `__oncopy` — Called when a value is copied

```kei
let u1 = User{ name: "Alice", age: 25 };
let u2 = u1;   // __oncopy(u1) called
                //   -> u1.name.__oncopy()   (string refcount++)
                //   -> u1.age — just copied
```

`__oncopy` is called:
- On variable assignment (copy)
- When passing arguments to functions
- When returning values from functions

### Reassignment sequence

When a value with lifecycle hooks is overwritten:

```kei
user.name = "Bob";
// 1. __destroy on OLD user.name (refcount-- on "Alice" buffer)
// 2. Copy "Bob" string struct
// 3. __oncopy on NEW user.name (refcount++ on "Bob" buffer)
```

For a full struct reassignment:

```kei
user = otherUser;
// 1. __destroy(user)       — recursively destroys all fields
// 2. memcpy(user, otherUser)
// 3. __oncopy(user)        — recursively copies all fields
```

## `move` — Explicit ownership transfer

For zero-cost transfer without lifecycle hook overhead, use `move`:

```kei
fn example() {
    let a = User{ name: "Alice", age: 25 };
    let b = move a;     // no __oncopy, no __destroy on a. Just bitwise copy.
    // a is now invalid — compile error if used
    print(b.name);      // works
}
```

**When to use move:**
- Performance-critical paths where copy overhead matters
- Transferring ownership to functions that consume the value
- One-time initialization patterns

## Function parameters

Parameter passing behavior:

### Default passing (copy + lifecycle hooks)
```kei
fn process(user: User) {
    // __oncopy on entry (user.name refcount++)
    print(user.name);
}   // __destroy on exit (user.name refcount--)

let user = User{ name: "Alice", age: 25 };
process(user);       // user still valid after call
process(user);       // can call again
```

### Move parameters (ownership transfer)
```kei
fn consume(move user: User) {
    // no __oncopy — owns user directly
    print(user.name);
}   // __destroy called here — user is consumed

let user = User{ name: "Alice", age: 25 };
consume(move user);  // user is gone after this call
// consume(user);    // ERROR - user was moved
```

**Function signature syntax:**
- `fn process(user: User)` — copy, keep original alive
- `fn consume(move user: User)` — transfer ownership, original becomes invalid

## Compiler optimizations

The compiler can optimize away lifecycle hook calls through static analysis:

### No-op elimination
Structs with only primitive fields have no-op `__destroy`/`__oncopy`. The compiler eliminates these calls entirely:

```kei
struct Point { x: f64; y: f64; }
let p1 = Point{ x: 1.0, y: 2.0 };
let p2 = p1;  // just memcpy, no function calls generated
```

### Last use optimization
The compiler can convert the last use of a variable to an implicit move:

```kei
fn example() {
    let user = createUser();
    processUser(user);      // last use detected → move instead of copy
}
```

### Dead code elimination
Unreachable lifecycle operations are removed:

```kei
if (false) {
    let user = User{ ... };  // entire block eliminated
}
```

## Return Value Optimization (RVO)

For struct returns, the compiler uses RVO to avoid unnecessary copying:

```kei
// Programmer writes:
fn createUser(name: string, age: int) -> User {
    return User{ name: name, age: age };
}
let user = createUser("Alice", 25);
```

```c
// Compiler generates (C equivalent):
void createUser(String name, int age, User* __out) {
    __out->name = name;
    __out->age = age;
}
User user;
createUser(name, 25, &user);
```

**Benefits:**
- No temporary objects created
- No unnecessary `__oncopy`/`__destroy` calls
- Direct construction at the destination

## Built-in memory functions

Kei provides built-in functions for heap allocation. These are part of the language (not extern), but require `unsafe` because manual memory management bypasses safety guarantees:

### `alloc<T>(count: usize) -> ptr<T>`

Allocates `count * sizeof(T)` bytes of heap memory and returns a typed pointer. Memory is uninitialized.

```kei
unsafe {
    let data = alloc<u8>(1024);       // allocate 1024 bytes
    let users = alloc<User>(10);      // allocate space for 10 Users
}
```

### `free<T>(p: ptr<T>)`

Frees memory previously allocated with `alloc`. Does not call `__destroy` on pointed-to values — the programmer is responsible for cleanup.

```kei
unsafe {
    let data = alloc<u8>(1024);
    // ... use data ...
    free(data);
}
```

**Why built-in, not extern?** `alloc`/`free` are aware of the Kei runtime (type sizes via `sizeof`, alignment). They compile down to C `malloc`/`free` but provide a typed interface. The compiler knows about them and can emit diagnostics (e.g., warning on double-free patterns).

### `sizeof(T) -> usize`

Returns the size in bytes of a type. Compile-time constant:

```kei
let size = sizeof(int);        // 4
let user_size = sizeof(User);  // depends on fields
```

## `unsafe` blocks

`unsafe` blocks allow operations that bypass the compiler's safety guarantees:

```kei
unsafe {
    let raw = alloc<u8>(1024);
    // raw pointer arithmetic
    let offset_ptr = raw + 512;
    free(raw);
}
```

**Allowed only in unsafe blocks:**
- Calling `alloc`/`free`
- Calling `extern fn` functions
- Raw pointer arithmetic
- Pointer type casts
- Direct memory access without bounds checking

**Safety note:** Code in `unsafe` blocks bypasses memory safety guarantees. The programmer is responsible for correctness.

## Debug safety checks

In debug builds, the compiler inserts runtime safety checks via KIR:

- **Array/slice bounds checking** — panic on out-of-bounds access
- **Division by zero** — panic with stack trace
- **Integer overflow detection** — wrap in release, panic in debug
- **Null pointer dereference** — immediate crash with diagnostic
- **Use-after-move detection** — catch moved value usage

All checks are **completely removed in release builds** for zero overhead.

## Memory layout guarantees

### All structs
- Laid out like C structs on the stack
- No hidden metadata in the struct itself
- Guaranteed ABI compatibility with C
- Lifecycle hooks are separate functions, not stored in the struct

### Arrays and slices
- Fixed arrays: contiguous stack allocation
- Dynamic arrays (`array`): stack struct + heap buffer
- Slices (`slice`): pointer + length on stack, no ownership

### Strings
- Stack struct: `{ ptr, offset, len, cap, count }`
- Heap buffer: raw byte data, shared via refcount
- COW semantics: mutation copies buffer when shared

## Performance characteristics

| Operation | Primitive-only struct | Struct with managed fields | unsafe struct |
|-----------|----------------------|---------------------------|---------------|
| Creation | Stack alloc | Stack alloc | Stack alloc |
| Assignment | memcpy | memcpy + __oncopy | memcpy + __oncopy |
| Function call | Copy | Copy + hooks | Copy + hooks |
| Scope exit | Nothing | __destroy | __destroy |
| Optimization | All hooks eliminated | Hooks on managed fields only | No auto-optimization |

## Standard library managed types

The following types are implemented as `unsafe struct` in the standard library, using lifecycle hooks for automatic resource management:

### `string` — COW string
```kei
// Internal implementation (simplified)
unsafe struct string {
    ptr: ptr<u8>;
    offset: usize;
    len: usize;
    cap: usize;
    count: ptr<u32>;

    fn __oncopy(self: string) -> string {
        self.count.increment();
        return self;
    }

    fn __destroy(self: string) {
        self.count.decrement();
        if (self.count.value == 0) {
            free(self.ptr);
            free(self.count);
        }
    }
}
```

### `Shared<T>` — Reference-counted pointer

`Shared<T>` is 2 × pointer size on the stack (pointer to data + pointer to refcount). The data itself lives on the heap. Assignment increments the refcount — no data copying.

```kei
unsafe struct Shared<T> {
    ptr: ptr<T>;
    count: ptr<u32>;

    fn __oncopy(self: Shared<T>) -> Shared<T> {
        self.count.increment();
        return self;
    }

    fn __destroy(self: Shared<T>) {
        self.count.decrement();
        if (self.count.value == 0) {
            self.ptr.destroy();
            free(self.ptr);
            free(self.count);
        }
    }
}
```

### `array<T>` — Heap-allocated array (COW, not resizable)
```kei
unsafe struct array<T> {
    data: ptr<T>;
    len: usize;
    cap: usize;
    count: ptr<u32>;

    fn __oncopy(self: array<T>) -> array<T> {
        self.count.increment();
        return self;
    }

    fn __destroy(self: array<T>) {
        self.count.decrement();
        if (self.count.value == 0) {
            for i in 0..self.len {
                self.data[i].__destroy();
            }
            free(self.data);
            free(self.count);
        }
    }

    // Element mutation triggers COW
    fn set(self: ptr<array<T>>, index: usize, value: T) {
        self.*.ensure_unique();  // copy buffer if refcount > 1
        self.*.data[index].__destroy();
        self.*.data[index] = value;
        value.__oncopy();
    }
}
```

**Note:** `array<T>` is not resizable — no `push`/`pop`. Use `List<T>` for growable collections.

### `List<T>` — Growable collection (deep copy)
```kei
unsafe struct List<T> {
    data: ptr<T>;
    len: usize;
    cap: usize;

    fn __oncopy(self: List<T>) -> List<T> {
        // Deep copy — allocates new buffer, copies all elements
        let new_data = alloc<T>(self.cap);
        for i in 0..self.len {
            new_data[i] = self.data[i];
            new_data[i].__oncopy();
        }
        return List<T>{ data: new_data, len: self.len, cap: self.cap };
    }

    fn __destroy(self: List<T>) {
        for i in 0..self.len {
            self.data[i].__destroy();
        }
        free(self.data);
    }
}
```

**Note:** `List<T>` always deep copies on assignment — no COW. Mutable by design (push/pop/insert/remove).
```

## Cyclic reference handling

Reference counting (used by `Shared<T>`, `string`, etc.) cannot automatically handle cycles. For cyclic data structures:

1. **Avoid cycles through design** — use tree/DAG structures when possible
2. **Break cycles manually** — use raw `ptr<T>` for back-pointers in `unsafe struct`
3. **Weak references** (future feature) — non-owning reference-counted pointers

```kei
// Tree with parent back-pointer
unsafe struct TreeNode {
    parent: ptr<TreeNode>;         // non-owning back-pointer
    children: array<TreeNode>;  // owns children
    value: int;

    fn __destroy(self: TreeNode) {
        // parent is non-owning, don't free
        self.children.__destroy();
    }
}
```

---

This memory model provides deterministic resource management for the majority of use cases through automatic lifecycle hooks, while allowing explicit control via `unsafe struct` when building low-level abstractions. The combination of stack-first allocation, COW semantics, and compiler optimizations delivers both safety and performance.
