# Memory Model

Kei's memory model provides deterministic resource management without garbage collection through a two-tier approach: all types live on the stack with compiler-managed lifecycle hooks for cleanup and copying.

## Overview

Kei achieves memory safety and performance through:
- **No garbage collector runtime** — all cleanup is compile-time determined
- **Lifecycle hooks** (`__destroy`/`__oncopy`) for deterministic resource management
- **Stack-first design** — all structs live on the stack, heap usage is explicit
- **Compiler auto-generation** of lifecycle hooks for `struct` types
- **Copy-on-Write** for standard library types like `string` and `dynarray<T>`

## Stack allocation (default)

All types in Kei are stack-allocated. Primitives, structs, and even types that manage heap resources (like `string`) have their struct data on the stack:

```kei
fn example() {
    let x = 42;                             // stack - integer
    let p = Point{ x: 1.0, y: 2.0 };      // stack - value struct
    let arr = [1, 2, 3, 4, 5];            // stack - fixed-size array
    let name = "hello";                     // stack - string struct (buffer on heap)
}   // __destroy called on all variables (no-op for primitives and Point)
```

**Characteristics:**
- **Allocation:** Stack frame for struct data
- **Assignment:** Copy + `__oncopy` call
- **Cleanup:** `__destroy` at scope exit (no-op when all fields are primitives)
- **Performance:** Optimal for primitive-only structs — equivalent to C

## Lifecycle hooks

Every type in Kei has two lifecycle hooks: `__destroy` and `__oncopy`. For `struct` types, these are auto-generated by the compiler. For `unsafe struct` types, they are user-defined.

### `__destroy` — Called when a value ceases to exist

```kei
fn example() {
    let user = User{ name: "Alice", age: 25 };
    // ...
} // __destroy(user) called here
  //   -> user.name.__destroy()   (string refcount--)
  //   -> user.age — no-op
```

`__destroy` is called:
- When a variable goes out of scope
- When a field is overwritten by assignment
- When the old value is replaced in an array element

### `__oncopy` — Called when a value is copied

```kei
let u1 = User{ name: "Alice", age: 25 };
let u2 = u1;   // __oncopy(u1) called
                //   -> u1.name.__oncopy()   (string refcount++)
                //   -> u1.age — just copied
```

`__oncopy` is called:
- On variable assignment (copy)
- When passing arguments to functions
- When returning values from functions

### Reassignment sequence

When a value with lifecycle hooks is overwritten:

```kei
user.name = "Bob";
// 1. __destroy on OLD user.name (refcount-- on "Alice" buffer)
// 2. Copy "Bob" string struct
// 3. __oncopy on NEW user.name (refcount++ on "Bob" buffer)
```

For a full struct reassignment:

```kei
user = otherUser;
// 1. __destroy(user)       — recursively destroys all fields
// 2. memcpy(user, otherUser)
// 3. __oncopy(user)        — recursively copies all fields
```

## `move` — Explicit ownership transfer

For zero-cost transfer without lifecycle hook overhead, use `move`:

```kei
fn example() {
    let a = User{ name: "Alice", age: 25 };
    let b = move a;     // no __oncopy, no __destroy on a. Just bitwise copy.
    // a is now invalid — compile error if used
    print(b.name);      // works
}
```

**When to use move:**
- Performance-critical paths where copy overhead matters
- Transferring ownership to functions that consume the value
- One-time initialization patterns

## Function parameters

Parameter passing behavior:

### Default passing (copy + lifecycle hooks)
```kei
fn process(user: User) {
    // __oncopy on entry (user.name refcount++)
    print(user.name);
}   // __destroy on exit (user.name refcount--)

let user = User{ name: "Alice", age: 25 };
process(user);       // user still valid after call
process(user);       // can call again
```

### Move parameters (ownership transfer)
```kei
fn consume(move user: User) {
    // no __oncopy — owns user directly
    print(user.name);
}   // __destroy called here — user is consumed

let user = User{ name: "Alice", age: 25 };
consume(move user);  // user is gone after this call
// consume(user);    // ERROR - user was moved
```

**Function signature syntax:**
- `fn process(user: User)` — copy, keep original alive
- `fn consume(move user: User)` — transfer ownership, original becomes invalid

## Compiler optimizations

The compiler can optimize away lifecycle hook calls through static analysis:

### No-op elimination
Structs with only primitive fields have no-op `__destroy`/`__oncopy`. The compiler eliminates these calls entirely:

```kei
struct Point { x: f64; y: f64; }
let p1 = Point{ x: 1.0, y: 2.0 };
let p2 = p1;  // just memcpy, no function calls generated
```

### Last use optimization
The compiler can convert the last use of a variable to an implicit move:

```kei
fn example() {
    let user = createUser();
    processUser(user);      // last use detected → move instead of copy
}
```

### Dead code elimination
Unreachable lifecycle operations are removed:

```kei
if (false) {
    let user = User{ ... };  // entire block eliminated
}
```

## Return Value Optimization (RVO)

For struct returns, the compiler uses RVO to avoid unnecessary copying:

```kei
// Programmer writes:
fn createUser(name: string, age: int) -> User {
    return User{ name: name, age: age };
}
let user = createUser("Alice", 25);
```

```c
// Compiler generates (C equivalent):
void createUser(String name, int age, User* __out) {
    __out->name = name;
    __out->age = age;
}
User user;
createUser(name, 25, &user);
```

**Benefits:**
- No temporary objects created
- No unnecessary `__oncopy`/`__destroy` calls
- Direct construction at the destination

## `unsafe` blocks

For scenarios requiring manual memory management, use `unsafe` blocks:

```kei
unsafe {
    let raw: ptr<u8> = c_malloc(1024);
    // raw pointer arithmetic allowed
    let offset_ptr = raw + 512;
    c_free(raw);
}
```

**Allowed in unsafe blocks:**
- Raw pointer arithmetic
- Manual allocation/deallocation
- External function calls
- Pointer type casts
- Direct memory access without bounds checking

**Safety note:** Code in `unsafe` blocks bypasses memory safety guarantees. The programmer is responsible for correctness.

## Debug safety checks

In debug builds, the compiler inserts runtime safety checks via KIR:

- **Array/slice bounds checking** — panic on out-of-bounds access
- **Division by zero** — panic with stack trace
- **Integer overflow detection** — wrap in release, panic in debug
- **Null pointer dereference** — immediate crash with diagnostic
- **Use-after-move detection** — catch moved value usage

All checks are **completely removed in release builds** for zero overhead.

## Memory layout guarantees

### All structs
- Laid out like C structs on the stack
- No hidden metadata in the struct itself
- Guaranteed ABI compatibility with C
- Lifecycle hooks are separate functions, not stored in the struct

### Arrays and slices
- Fixed arrays: contiguous stack allocation
- Dynamic arrays (`dynarray`): stack struct + heap buffer
- Slices (`slice`): pointer + length on stack, no ownership

### Strings
- Stack struct: `{ ptr, offset, len, cap, count }`
- Heap buffer: raw byte data, shared via refcount
- COW semantics: mutation copies buffer when shared

## Performance characteristics

| Operation | Primitive-only struct | Struct with managed fields | unsafe struct |
|-----------|----------------------|---------------------------|---------------|
| Creation | Stack alloc | Stack alloc | Stack alloc |
| Assignment | memcpy | memcpy + __oncopy | memcpy + __oncopy |
| Function call | Copy | Copy + hooks | Copy + hooks |
| Scope exit | Nothing | __destroy | __destroy |
| Optimization | All hooks eliminated | Hooks on managed fields only | No auto-optimization |

## Standard library managed types

The following types are implemented as `unsafe struct` in the standard library, using lifecycle hooks for automatic resource management:

### `string` — COW string
```kei
// Internal implementation (simplified)
unsafe struct string {
    ptr: ptr<u8>;
    offset: usize;
    len: usize;
    cap: usize;
    count: ptr<u32>;

    fn __oncopy(self: string) -> string {
        self.count.increment();
        return self;
    }

    fn __destroy(self: string) {
        self.count.decrement();
        if (self.count.value == 0) {
            c_free(self.ptr);
            c_free(self.count);
        }
    }
}
```

### `Shared<T>` — Reference-counted pointer
```kei
unsafe struct Shared<T> {
    ptr: ptr<T>;
    count: ptr<u32>;

    fn __oncopy(self: Shared<T>) -> Shared<T> {
        self.count.increment();
        return self;
    }

    fn __destroy(self: Shared<T>) {
        self.count.decrement();
        if (self.count.value == 0) {
            self.ptr.destroy();
            c_free(self.ptr);
            c_free(self.count);
        }
    }
}
```

### `dynarray<T>` — Dynamic array
```kei
unsafe struct dynarray<T> {
    data: ptr<T>;
    len: usize;
    cap: usize;
    count: ptr<u32>;

    fn __oncopy(self: dynarray<T>) -> dynarray<T> {
        self.count.increment();
        return self;
    }

    fn __destroy(self: dynarray<T>) {
        self.count.decrement();
        if (self.count.value == 0) {
            // destroy each element
            for i in 0..self.len {
                self.data[i].__destroy();
            }
            c_free(self.data);
            c_free(self.count);
        }
    }
}
```

## Cyclic reference handling

Reference counting (used by `Shared<T>`, `string`, etc.) cannot automatically handle cycles. For cyclic data structures:

1. **Avoid cycles through design** — use tree/DAG structures when possible
2. **Break cycles manually** — use raw `ptr<T>` for back-pointers in `unsafe struct`
3. **Weak references** (future feature) — non-owning reference-counted pointers

```kei
// Tree with parent back-pointer
unsafe struct TreeNode {
    parent: ptr<TreeNode>;         // non-owning back-pointer
    children: dynarray<TreeNode>;  // owns children
    value: int;

    fn __destroy(self: TreeNode) {
        // parent is non-owning, don't free
        self.children.__destroy();
    }
}
```

---

This memory model provides deterministic resource management for the majority of use cases through automatic lifecycle hooks, while allowing explicit control via `unsafe struct` when building low-level abstractions. The combination of stack-first allocation, COW semantics, and compiler optimizations delivers both safety and performance.
