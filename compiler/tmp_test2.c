/* Generated by the Kei compiler */
/* Kei runtime — minimal C runtime for compiled Kei programs */
#ifndef KEI_RUNTIME_H
#define KEI_RUNTIME_H

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* ─── String type — COW refcounted string ─────────────────────────────────── */

typedef struct {
    char* data;      /* heap-allocated or static pointer */
    int64_t len;     /* byte length (not including null terminator) */
    int64_t cap;     /* allocated capacity (0 for literals) */
    int64_t* ref;    /* refcount pointer (NULL for static/literal strings) */
} kei_string;

/* Create a string from a C string literal (no allocation, ref=NULL) */
static kei_string kei_string_literal(const char* s) {
    kei_string r;
    r.data = (char*)s;
    r.len = (int64_t)strlen(s);
    r.cap = 0;
    r.ref = NULL;
    return r;
}

/* Increment refcount (COW copy) */
static kei_string kei_string_copy(kei_string s) {
    if (s.ref != NULL) {
        (*s.ref)++;
    }
    return s;
}

/* Decrement refcount, free if zero */
static void kei_string_destroy(kei_string* s) {
    if (s->ref != NULL) {
        (*s->ref)--;
        if (*s->ref <= 0) {
            free(s->data);
            free(s->ref);
        }
        s->ref = NULL;
        s->data = NULL;
    }
}

/* Allocate a new string with given capacity */
static kei_string kei_string_alloc(int64_t len) {
    kei_string r;
    r.cap = len + 1;
    r.data = (char*)malloc((size_t)r.cap);
    r.len = len;
    r.ref = (int64_t*)malloc(sizeof(int64_t));
    *r.ref = 1;
    r.data[len] = '\0';
    return r;
}

/* Concatenate two strings — always allocates a new string */
static kei_string kei_string_concat(kei_string a, kei_string b) {
    int64_t newLen = a.len + b.len;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, a.data, (size_t)a.len);
    memcpy(r.data + a.len, b.data, (size_t)b.len);
    r.data[newLen] = '\0';
    return r;
}

/* Return string length */
static int64_t kei_string_len(kei_string s) {
    return s.len;
}

/* Compare two strings for equality */
static bool kei_string_eq(kei_string a, kei_string b) {
    if (a.len != b.len) return false;
    if (a.data == b.data) return true;
    return memcmp(a.data, b.data, (size_t)a.len) == 0;
}

/* Substring — allocates a new string [start, end) */
static kei_string kei_string_substr(kei_string s, int64_t start, int64_t end) {
    if (start < 0) start = 0;
    if (end > s.len) end = s.len;
    if (start >= end) {
        return kei_string_literal("");
    }
    int64_t newLen = end - start;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, s.data + start, (size_t)newLen);
    r.data[newLen] = '\0';
    return r;
}

/* ─── Panic ───────────────────────────────────────────────────────────────── */

static void kei_panic(const char* msg) {
    fprintf(stderr, "panic: %s\n", msg);
    exit(1);
}

/* ─── Print functions ─────────────────────────────────────────────────────── */

static void kei_print_string(kei_string s) {
    printf("%.*s\n", (int)s.len, s.data);
}

static void kei_print_i32(int32_t v) {
    printf("%d\n", (int)v);
}

static void kei_print_i64(int64_t v) {
    printf("%lld\n", (long long)v);
}

static void kei_print_f32(float v) {
    printf("%g\n", (double)v);
}

static void kei_print_f64(double v) {
    printf("%g\n", v);
}

static void kei_print_bool(bool v) {
    printf("%s\n", v ? "true" : "false");
}

/* ─── Bounds check ────────────────────────────────────────────────────────── */

static void kei_bounds_check(int64_t index, int64_t length) {
    if (index < 0 || index >= length) {
        fprintf(stderr, "panic: index out of bounds: index %lld, length %lld\n",
                (long long)index, (long long)length);
        exit(1);
    }
}

/* Null check */
static void kei_null_check(const void* ptr) {
    if (ptr == NULL) {
        kei_panic("null pointer dereference");
    }
}

/* Assert check */
static void kei_assert(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "assertion failed: %s\n", msg);
        exit(1);
    }
}

/* Require check */
static void kei_require(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "requirement failed: %s\n", msg);
        exit(1);
    }
}

#endif /* KEI_RUNTIME_H */

struct Vec2;

struct Vec2 {
    int32_t x;
    int32_t y;
};

extern int32_t putchar(int32_t);
extern int32_t getchar(void);
extern void kei_print_i32(int32_t);
extern void kei_print_i64(int64_t);
extern void kei_print_f64(double);
extern void kei_print_f32(float);
extern void kei_print_string(kei_string);
extern void kei_print_bool(bool);

void io_print_string(kei_string _vvalue);
void io_print_i32(int32_t _vvalue);
void io_print_i64(int64_t _vvalue);
void io_print_f64(double _vvalue);
void io_print_f32(float _vvalue);
void io_print_bool(bool _vvalue);
void io_putc(int32_t _vc);
int32_t io_getc(void);
void io_newline(void);
struct Vec2 Vec2_op_add(struct Vec2* _vself, struct Vec2* _vother);
struct Vec2 Vec2_op_sub(struct Vec2* _vself, struct Vec2* _vother);
int main(void);

void io_print_string(kei_string _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_string(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i32(int32_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i64(int64_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f64(double _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f32(float _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_bool(bool _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_bool(_vvalue);
    _v0 = 0;
    return;
}

void io_putc(int32_t _vc) {
    int32_t _v0;

entry: ;
    _v0 = putchar(_vc);
    return;
}

int32_t io_getc(void) {
    int32_t _v0;

entry: ;
    _v0 = getchar();
    return _v0;
}

void io_newline(void) {
    int32_t _v0;
    int32_t _v1;

entry: ;
    _v0 = 10;
    _v1 = putchar(_v0);
    return;
}

struct Vec2 Vec2_op_add(struct Vec2* _vself, struct Vec2* _vother) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t* _v1;
    int32_t _v2;
    int32_t* _v3;
    int32_t _v4;
    int32_t _v5;
    int32_t* _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    int32_t _v10;
    int32_t _v11;
    int32_t* _v12;
    struct Vec2 _v13;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = &_vself->x;
    _v2 = *_v1;
    _v3 = &_vother->x;
    _v4 = *_v3;
    _v5 = _v2 + _v4;
    _v6 = &_v0->x;
    *_v6 = _v5;
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = &_vother->y;
    _v10 = *_v9;
    _v11 = _v8 + _v10;
    _v12 = &_v0->y;
    *_v12 = _v11;
    _v13 = *_v0;
    return _v13;
}

struct Vec2 Vec2_op_sub(struct Vec2* _vself, struct Vec2* _vother) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t* _v1;
    int32_t _v2;
    int32_t* _v3;
    int32_t _v4;
    int32_t _v5;
    int32_t* _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    int32_t _v10;
    int32_t _v11;
    int32_t* _v12;
    struct Vec2 _v13;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = &_vself->x;
    _v2 = *_v1;
    _v3 = &_vother->x;
    _v4 = *_v3;
    _v5 = _v2 - _v4;
    _v6 = &_v0->x;
    *_v6 = _v5;
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = &_vother->y;
    _v10 = *_v9;
    _v11 = _v8 - _v10;
    _v12 = &_v0->y;
    *_v12 = _v11;
    _v13 = *_v0;
    return _v13;
}

int main(void) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t _v1;
    int32_t* _v2;
    int32_t _v3;
    int32_t* _v4;
    struct Vec2 _v5_alloc;
    struct Vec2* _v5;
    int32_t _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    struct Vec2 _v10_alloc;
    struct Vec2* _v10;
    int32_t _v11;
    int32_t* _v12;
    int32_t _v13;
    int32_t* _v14;
    struct Vec2 _v15;
    struct Vec2 _v16_alloc;
    struct Vec2* _v16;
    struct Vec2 _v17;
    struct Vec2 _v18_alloc;
    struct Vec2* _v18;
    int32_t* _v19;
    int32_t _v20;
    int32_t _v21;
    int32_t* _v22;
    int32_t _v23;
    int32_t _v24;
    struct Vec2 _v25;
    struct Vec2 _v26_alloc;
    struct Vec2* _v26;
    struct Vec2 _v27;
    struct Vec2 _v28_alloc;
    struct Vec2* _v28;
    int32_t* _v29;
    int32_t _v30;
    int32_t _v31;
    int32_t* _v32;
    int32_t _v33;
    int32_t _v34;
    int32_t _v35;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = 1;
    _v2 = &_v0->x;
    *_v2 = _v1;
    _v3 = 1;
    _v4 = &_v0->y;
    *_v4 = _v3;
    _v5 = &_v5_alloc;
    _v6 = 2;
    _v7 = &_v5->x;
    *_v7 = _v6;
    _v8 = 3;
    _v9 = &_v5->y;
    *_v9 = _v8;
    _v10 = &_v10_alloc;
    _v11 = 4;
    _v12 = &_v10->x;
    *_v12 = _v11;
    _v13 = 5;
    _v14 = &_v10->y;
    *_v14 = _v13;
    _v15 = Vec2_op_add(_v0, _v5);
    _v16 = &_v16_alloc;
    *_v16 = _v15;
    _v17 = Vec2_op_add(_v16, _v10);
    _v18 = &_v18_alloc;
    *_v18 = _v17;
    _v19 = &_v18->x;
    _v20 = *_v19;
    io_print_i32(_v20);
    _v21 = 0;
    _v22 = &_v18->y;
    _v23 = *_v22;
    io_print_i32(_v23);
    _v24 = 0;
    _v25 = Vec2_op_add(_v0, _v5);
    _v26 = &_v26_alloc;
    *_v26 = _v25;
    _v27 = Vec2_op_sub(_v26, _v10);
    _v28 = &_v28_alloc;
    *_v28 = _v27;
    _v29 = &_v28->x;
    _v30 = *_v29;
    io_print_i32(_v30);
    _v31 = 0;
    _v32 = &_v28->y;
    _v33 = *_v32;
    io_print_i32(_v33);
    _v34 = 0;
    _v35 = 0;
    return _v35;
}
