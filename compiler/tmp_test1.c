/* Generated by the Kei compiler */
/* Kei runtime — minimal C runtime for compiled Kei programs */
#ifndef KEI_RUNTIME_H
#define KEI_RUNTIME_H

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* ─── String type — COW refcounted string ─────────────────────────────────── */

typedef struct {
    char* data;      /* heap-allocated or static pointer */
    int64_t len;     /* byte length (not including null terminator) */
    int64_t cap;     /* allocated capacity (0 for literals) */
    int64_t* ref;    /* refcount pointer (NULL for static/literal strings) */
} kei_string;

/* Create a string from a C string literal (no allocation, ref=NULL) */
static kei_string kei_string_literal(const char* s) {
    kei_string r;
    r.data = (char*)s;
    r.len = (int64_t)strlen(s);
    r.cap = 0;
    r.ref = NULL;
    return r;
}

/* Increment refcount (COW copy) */
static kei_string kei_string_copy(kei_string s) {
    if (s.ref != NULL) {
        (*s.ref)++;
    }
    return s;
}

/* Decrement refcount, free if zero */
static void kei_string_destroy(kei_string* s) {
    if (s->ref != NULL) {
        (*s->ref)--;
        if (*s->ref <= 0) {
            free(s->data);
            free(s->ref);
        }
        s->ref = NULL;
        s->data = NULL;
    }
}

/* Allocate a new string with given capacity */
static kei_string kei_string_alloc(int64_t len) {
    kei_string r;
    r.cap = len + 1;
    r.data = (char*)malloc((size_t)r.cap);
    r.len = len;
    r.ref = (int64_t*)malloc(sizeof(int64_t));
    *r.ref = 1;
    r.data[len] = '\0';
    return r;
}

/* Concatenate two strings — always allocates a new string */
static kei_string kei_string_concat(kei_string a, kei_string b) {
    int64_t newLen = a.len + b.len;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, a.data, (size_t)a.len);
    memcpy(r.data + a.len, b.data, (size_t)b.len);
    r.data[newLen] = '\0';
    return r;
}

/* Return string length */
static int64_t kei_string_len(kei_string s) {
    return s.len;
}

/* Compare two strings for equality */
static bool kei_string_eq(kei_string a, kei_string b) {
    if (a.len != b.len) return false;
    if (a.data == b.data) return true;
    return memcmp(a.data, b.data, (size_t)a.len) == 0;
}

/* Substring — allocates a new string [start, end) */
static kei_string kei_string_substr(kei_string s, int64_t start, int64_t end) {
    if (start < 0) start = 0;
    if (end > s.len) end = s.len;
    if (start >= end) {
        return kei_string_literal("");
    }
    int64_t newLen = end - start;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, s.data + start, (size_t)newLen);
    r.data[newLen] = '\0';
    return r;
}

/* ─── Panic ───────────────────────────────────────────────────────────────── */

static void kei_panic(const char* msg) {
    fprintf(stderr, "panic: %s\n", msg);
    exit(1);
}

/* ─── Print functions ─────────────────────────────────────────────────────── */

static void kei_print_string(kei_string s) {
    printf("%.*s\n", (int)s.len, s.data);
}

static void kei_print_i32(int32_t v) {
    printf("%d\n", (int)v);
}

static void kei_print_i64(int64_t v) {
    printf("%lld\n", (long long)v);
}

static void kei_print_f32(float v) {
    printf("%g\n", (double)v);
}

static void kei_print_f64(double v) {
    printf("%g\n", v);
}

static void kei_print_bool(bool v) {
    printf("%s\n", v ? "true" : "false");
}

/* ─── Bounds check ────────────────────────────────────────────────────────── */

static void kei_bounds_check(int64_t index, int64_t length) {
    if (index < 0 || index >= length) {
        fprintf(stderr, "panic: index out of bounds: index %lld, length %lld\n",
                (long long)index, (long long)length);
        exit(1);
    }
}

/* Null check */
static void kei_null_check(const void* ptr) {
    if (ptr == NULL) {
        kei_panic("null pointer dereference");
    }
}

/* Assert check */
static void kei_assert(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "assertion failed: %s\n", msg);
        exit(1);
    }
}

/* Require check */
static void kei_require(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "requirement failed: %s\n", msg);
        exit(1);
    }
}

#endif /* KEI_RUNTIME_H */

struct Vec2;

struct Vec2 {
    int32_t x;
    int32_t y;
};

extern int32_t putchar(int32_t);
extern int32_t getchar(void);
extern void kei_print_i32(int32_t);
extern void kei_print_i64(int64_t);
extern void kei_print_f64(double);
extern void kei_print_f32(float);
extern void kei_print_string(kei_string);
extern void kei_print_bool(bool);

void io_print_string(kei_string _vvalue);
void io_print_i32(int32_t _vvalue);
void io_print_i64(int64_t _vvalue);
void io_print_f64(double _vvalue);
void io_print_f32(float _vvalue);
void io_print_bool(bool _vvalue);
void io_putc(int32_t _vc);
int32_t io_getc(void);
void io_newline(void);
struct Vec2 Vec2_op_add(struct Vec2* _vself, struct Vec2* _vother);
struct Vec2 Vec2_op_sub(struct Vec2* _vself, struct Vec2* _vother);
bool Vec2_op_eq(struct Vec2* _vself, struct Vec2* _vother);
int32_t Vec2_dot(struct Vec2* _vself, struct Vec2* _vother);
int32_t Vec2_magnitude_sq(struct Vec2* _vself);
int main(void);

void io_print_string(kei_string _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_string(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i32(int32_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i64(int64_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f64(double _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f32(float _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_bool(bool _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_bool(_vvalue);
    _v0 = 0;
    return;
}

void io_putc(int32_t _vc) {
    int32_t _v0;

entry: ;
    _v0 = putchar(_vc);
    return;
}

int32_t io_getc(void) {
    int32_t _v0;

entry: ;
    _v0 = getchar();
    return _v0;
}

void io_newline(void) {
    int32_t _v0;
    int32_t _v1;

entry: ;
    _v0 = 10;
    _v1 = putchar(_v0);
    return;
}

struct Vec2 Vec2_op_add(struct Vec2* _vself, struct Vec2* _vother) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t* _v1;
    int32_t _v2;
    int32_t* _v3;
    int32_t _v4;
    int32_t _v5;
    int32_t* _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    int32_t _v10;
    int32_t _v11;
    int32_t* _v12;
    struct Vec2 _v13;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = &_vself->x;
    _v2 = *_v1;
    _v3 = &_vother->x;
    _v4 = *_v3;
    _v5 = _v2 + _v4;
    _v6 = &_v0->x;
    *_v6 = _v5;
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = &_vother->y;
    _v10 = *_v9;
    _v11 = _v8 + _v10;
    _v12 = &_v0->y;
    *_v12 = _v11;
    _v13 = *_v0;
    return _v13;
}

struct Vec2 Vec2_op_sub(struct Vec2* _vself, struct Vec2* _vother) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t* _v1;
    int32_t _v2;
    int32_t* _v3;
    int32_t _v4;
    int32_t _v5;
    int32_t* _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    int32_t _v10;
    int32_t _v11;
    int32_t* _v12;
    struct Vec2 _v13;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = &_vself->x;
    _v2 = *_v1;
    _v3 = &_vother->x;
    _v4 = *_v3;
    _v5 = _v2 - _v4;
    _v6 = &_v0->x;
    *_v6 = _v5;
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = &_vother->y;
    _v10 = *_v9;
    _v11 = _v8 - _v10;
    _v12 = &_v0->y;
    *_v12 = _v11;
    _v13 = *_v0;
    return _v13;
}

bool Vec2_op_eq(struct Vec2* _vself, struct Vec2* _vother) {
    int32_t* _v1;
    int32_t _v2;
    int32_t* _v3;
    int32_t _v4;
    bool _v5;
    bool _v6;
    bool _v13;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    int32_t _v10;
    bool _v11;

entry: ;
    _v1 = &_vself->x;
    _v2 = *_v1;
    _v3 = &_vother->x;
    _v4 = *_v3;
    _v5 = _v2 == _v4;
    if (_v5) goto and_rhs_0; else goto and_false_1;
and_false_1:
    _v6 = false;
    _v13 = (bool)_v6;
    goto and_end_2;
and_rhs_0:
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = &_vother->y;
    _v10 = *_v9;
    _v11 = _v8 == _v10;
    _v13 = (bool)_v11;
    goto and_end_2;
and_end_2:
    return _v13;
}

int32_t Vec2_dot(struct Vec2* _vself, struct Vec2* _vother) {
    int32_t* _v0;
    int32_t _v1;
    int32_t* _v2;
    int32_t _v3;
    int32_t _v4;
    int32_t* _v5;
    int32_t _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t _v9;
    int32_t _v10;

entry: ;
    _v0 = &_vself->x;
    _v1 = *_v0;
    _v2 = &_vother->x;
    _v3 = *_v2;
    _v4 = _v1 * _v3;
    _v5 = &_vself->y;
    _v6 = *_v5;
    _v7 = &_vother->y;
    _v8 = *_v7;
    _v9 = _v6 * _v8;
    _v10 = _v4 + _v9;
    return _v10;
}

int32_t Vec2_magnitude_sq(struct Vec2* _vself) {
    int32_t* _v0;
    int32_t _v1;
    int32_t* _v2;
    int32_t _v3;
    int32_t _v4;
    int32_t* _v5;
    int32_t _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t _v9;
    int32_t _v10;

entry: ;
    _v0 = &_vself->x;
    _v1 = *_v0;
    _v2 = &_vself->x;
    _v3 = *_v2;
    _v4 = _v1 * _v3;
    _v5 = &_vself->y;
    _v6 = *_v5;
    _v7 = &_vself->y;
    _v8 = *_v7;
    _v9 = _v6 * _v8;
    _v10 = _v4 + _v9;
    return _v10;
}

int main(void) {
    struct Vec2 _v0_alloc;
    struct Vec2* _v0;
    int32_t _v1;
    int32_t* _v2;
    int32_t _v3;
    int32_t* _v4;
    struct Vec2 _v5_alloc;
    struct Vec2* _v5;
    int32_t _v6;
    int32_t* _v7;
    int32_t _v8;
    int32_t* _v9;
    struct Vec2 _v10;
    struct Vec2 _v11_alloc;
    struct Vec2* _v11;
    int32_t* _v12;
    int32_t _v13;
    int32_t _v14;
    int32_t* _v15;
    int32_t _v16;
    int32_t _v17;
    struct Vec2 _v18;
    struct Vec2 _v19_alloc;
    struct Vec2* _v19;
    int32_t* _v20;
    int32_t _v21;
    int32_t _v22;
    int32_t* _v23;
    int32_t _v24;
    int32_t _v25;
    bool _v26;
    int32_t _v27;
    bool _v28;
    int32_t _v29;
    struct Vec2 _v30;
    struct Vec2 _v31_alloc;
    struct Vec2* _v31;
    int32_t _v32;
    int32_t _v33;
    int32_t _v34;
    int32_t _v35;
    int32_t _v36;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = 3;
    _v2 = &_v0->x;
    *_v2 = _v1;
    _v3 = 4;
    _v4 = &_v0->y;
    *_v4 = _v3;
    _v5 = &_v5_alloc;
    _v6 = 1;
    _v7 = &_v5->x;
    *_v7 = _v6;
    _v8 = 2;
    _v9 = &_v5->y;
    *_v9 = _v8;
    _v10 = Vec2_op_add(_v0, _v5);
    _v11 = &_v11_alloc;
    *_v11 = _v10;
    _v12 = &_v11->x;
    _v13 = *_v12;
    io_print_i32(_v13);
    _v14 = 0;
    _v15 = &_v11->y;
    _v16 = *_v15;
    io_print_i32(_v16);
    _v17 = 0;
    _v18 = Vec2_op_sub(_v0, _v5);
    _v19 = &_v19_alloc;
    *_v19 = _v18;
    _v20 = &_v19->x;
    _v21 = *_v20;
    io_print_i32(_v21);
    _v22 = 0;
    _v23 = &_v19->y;
    _v24 = *_v23;
    io_print_i32(_v24);
    _v25 = 0;
    _v26 = Vec2_op_eq(_v0, _v0);
    io_print_bool(_v26);
    _v27 = 0;
    _v28 = Vec2_op_eq(_v0, _v5);
    io_print_bool(_v28);
    _v29 = 0;
    _v30 = *_v5;
    _v31 = &_v31_alloc;
    *_v31 = _v30;
    _v32 = Vec2_dot(_v0, _v31);
    io_print_i32(_v32);
    _v33 = 0;
    _v34 = Vec2_magnitude_sq(_v0);
    io_print_i32(_v34);
    _v35 = 0;
    _v36 = 0;
    return _v36;
}
