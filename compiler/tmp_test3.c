/* Generated by the Kei compiler */
/* Kei runtime — minimal C runtime for compiled Kei programs */
#ifndef KEI_RUNTIME_H
#define KEI_RUNTIME_H

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

/* ─── String type — COW refcounted string ─────────────────────────────────── */

typedef struct {
    char* data;      /* heap-allocated or static pointer */
    int64_t len;     /* byte length (not including null terminator) */
    int64_t cap;     /* allocated capacity (0 for literals) */
    int64_t* ref;    /* refcount pointer (NULL for static/literal strings) */
} kei_string;

/* Create a string from a C string literal (no allocation, ref=NULL) */
static kei_string kei_string_literal(const char* s) {
    kei_string r;
    r.data = (char*)s;
    r.len = (int64_t)strlen(s);
    r.cap = 0;
    r.ref = NULL;
    return r;
}

/* Increment refcount (COW copy) */
static kei_string kei_string_copy(kei_string s) {
    if (s.ref != NULL) {
        (*s.ref)++;
    }
    return s;
}

/* Decrement refcount, free if zero */
static void kei_string_destroy(kei_string* s) {
    if (s->ref != NULL) {
        (*s->ref)--;
        if (*s->ref <= 0) {
            free(s->data);
            free(s->ref);
        }
        s->ref = NULL;
        s->data = NULL;
    }
}

/* Allocate a new string with given capacity */
static kei_string kei_string_alloc(int64_t len) {
    kei_string r;
    r.cap = len + 1;
    r.data = (char*)malloc((size_t)r.cap);
    r.len = len;
    r.ref = (int64_t*)malloc(sizeof(int64_t));
    *r.ref = 1;
    r.data[len] = '\0';
    return r;
}

/* Concatenate two strings — always allocates a new string */
static kei_string kei_string_concat(kei_string a, kei_string b) {
    int64_t newLen = a.len + b.len;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, a.data, (size_t)a.len);
    memcpy(r.data + a.len, b.data, (size_t)b.len);
    r.data[newLen] = '\0';
    return r;
}

/* Return string length */
static int64_t kei_string_len(kei_string s) {
    return s.len;
}

/* Compare two strings for equality */
static bool kei_string_eq(kei_string a, kei_string b) {
    if (a.len != b.len) return false;
    if (a.data == b.data) return true;
    return memcmp(a.data, b.data, (size_t)a.len) == 0;
}

/* Substring — allocates a new string [start, end) */
static kei_string kei_string_substr(kei_string s, int64_t start, int64_t end) {
    if (start < 0) start = 0;
    if (end > s.len) end = s.len;
    if (start >= end) {
        return kei_string_literal("");
    }
    int64_t newLen = end - start;
    kei_string r = kei_string_alloc(newLen);
    memcpy(r.data, s.data + start, (size_t)newLen);
    r.data[newLen] = '\0';
    return r;
}

/* ─── Panic ───────────────────────────────────────────────────────────────── */

static void kei_panic(const char* msg) {
    fprintf(stderr, "panic: %s\n", msg);
    exit(1);
}

/* ─── Print functions ─────────────────────────────────────────────────────── */

static void kei_print_string(kei_string s) {
    printf("%.*s\n", (int)s.len, s.data);
}

static void kei_print_i32(int32_t v) {
    printf("%d\n", (int)v);
}

static void kei_print_i64(int64_t v) {
    printf("%lld\n", (long long)v);
}

static void kei_print_f32(float v) {
    printf("%g\n", (double)v);
}

static void kei_print_f64(double v) {
    printf("%g\n", v);
}

static void kei_print_bool(bool v) {
    printf("%s\n", v ? "true" : "false");
}

/* ─── Bounds check ────────────────────────────────────────────────────────── */

static void kei_bounds_check(int64_t index, int64_t length) {
    if (index < 0 || index >= length) {
        fprintf(stderr, "panic: index out of bounds: index %lld, length %lld\n",
                (long long)index, (long long)length);
        exit(1);
    }
}

/* Null check */
static void kei_null_check(const void* ptr) {
    if (ptr == NULL) {
        kei_panic("null pointer dereference");
    }
}

/* Assert check */
static void kei_assert(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "assertion failed: %s\n", msg);
        exit(1);
    }
}

/* Require check */
static void kei_require(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "requirement failed: %s\n", msg);
        exit(1);
    }
}

#endif /* KEI_RUNTIME_H */

struct Counter;

struct Counter {
    int32_t val;
};

extern int32_t putchar(int32_t);
extern int32_t getchar(void);
extern void kei_print_i32(int32_t);
extern void kei_print_i64(int64_t);
extern void kei_print_f64(double);
extern void kei_print_f32(float);
extern void kei_print_string(kei_string);
extern void kei_print_bool(bool);

void io_print_string(kei_string _vvalue);
void io_print_i32(int32_t _vvalue);
void io_print_i64(int64_t _vvalue);
void io_print_f64(double _vvalue);
void io_print_f32(float _vvalue);
void io_print_bool(bool _vvalue);
void io_putc(int32_t _vc);
int32_t io_getc(void);
void io_newline(void);
struct Counter Counter___oncopy(struct Counter* _vself);
void Counter___destroy(struct Counter* _vself);
int main(void);

void io_print_string(kei_string _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_string(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i32(int32_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_i64(int64_t _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_i64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f64(double _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f64(_vvalue);
    _v0 = 0;
    return;
}

void io_print_f32(float _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_f32(_vvalue);
    _v0 = 0;
    return;
}

void io_print_bool(bool _vvalue) {
    int32_t _v0;

entry: ;
    kei_print_bool(_vvalue);
    _v0 = 0;
    return;
}

void io_putc(int32_t _vc) {
    int32_t _v0;

entry: ;
    _v0 = putchar(_vc);
    return;
}

int32_t io_getc(void) {
    int32_t _v0;

entry: ;
    _v0 = getchar();
    return _v0;
}

void io_newline(void) {
    int32_t _v0;
    int32_t _v1;

entry: ;
    _v0 = 10;
    _v1 = putchar(_v0);
    return;
}

struct Counter Counter___oncopy(struct Counter* _vself) {
    kei_string _v0;
    int32_t _v1;
    struct Counter _v2_alloc;
    struct Counter* _v2;
    int32_t* _v3;
    int32_t _v4;
    int32_t _v5;
    int32_t _v6;
    int32_t* _v7;
    struct Counter _v8;

entry: ;
    _v0 = kei_string_literal("copied");
    io_print_string(_v0);
    _v1 = 0;
    _v2 = &_v2_alloc;
    _v3 = &_vself->val;
    _v4 = *_v3;
    _v5 = 100;
    _v6 = _v4 + _v5;
    _v7 = &_v2->val;
    *_v7 = _v6;
    _v8 = *_v2;
    return _v8;
}

void Counter___destroy(struct Counter* _vself) {
    kei_string _v0;
    int32_t _v1;
    int32_t* _v2;
    int32_t _v3;
    int32_t _v4;

entry: ;
    _v0 = kei_string_literal("destroy");
    io_print_string(_v0);
    _v1 = 0;
    _v2 = &_vself->val;
    _v3 = *_v2;
    io_print_i32(_v3);
    _v4 = 0;
    return;
}

int main(void) {
    struct Counter _v0_alloc;
    struct Counter* _v0;
    int32_t _v1;
    int32_t* _v2;
    struct Counter _v3;
    struct Counter _v4_alloc;
    struct Counter* _v4;
    int32_t* _v5;
    int32_t _v6;
    int32_t _v7;
    int32_t* _v8;
    int32_t _v9;
    int32_t _v10;
    int32_t _v11;

entry: ;
    _v0 = &_v0_alloc;
    _v1 = 42;
    _v2 = &_v0->val;
    *_v2 = _v1;
    _v3 = *_v0;
    _v4 = &_v4_alloc;
    _v3 = Counter___oncopy(&_v3);
    *_v4 = _v3;
    _v5 = &_v0->val;
    _v6 = *_v5;
    io_print_i32(_v6);
    _v7 = 0;
    _v8 = &_v4->val;
    _v9 = *_v8;
    io_print_i32(_v9);
    _v10 = 0;
    _v11 = 0;
    Counter___destroy(_v4);
    Counter___destroy(_v0);
    return _v11;
}
