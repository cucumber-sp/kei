/**
 * Type-checks declarations (fn, struct, enum, etc.).
 */

import type {
  Declaration,
  ExternFunctionDecl,
  FunctionDecl,
  ImportDecl,
  StaticDecl,
  TypeAlias,
} from "../ast/nodes.ts";
import type { Checker } from "./checker.ts";
import { EnumChecker } from "./enum-checker.ts";
import { StructChecker } from "./struct-checker.ts";
import { functionSymbol, moduleSymbol, typeSymbol, variableSymbol } from "./symbols.ts";
import type { FunctionType, ModuleType, ParamInfo, Type } from "./types";
import {
  ERROR_TYPE,
  functionType,
  I32_TYPE,
  isAssignableTo,
  isErrorType,
  TypeKind,
  typeToString,
  VOID_TYPE,
} from "./types";

export class DeclarationChecker {
  private checker: Checker;
  private structChecker: StructChecker;
  private enumChecker: EnumChecker;

  constructor(checker: Checker) {
    this.checker = checker;
    this.structChecker = new StructChecker(checker);
    this.enumChecker = new EnumChecker(checker);
  }

  /**
   * First pass: register all top-level declarations in the global scope.
   * This enables forward references between types and functions.
   */
  registerDeclaration(decl: Declaration): void {
    switch (decl.kind) {
      case "FunctionDecl":
        this.registerFunction(decl);
        break;
      case "ExternFunctionDecl":
        this.registerExternFunction(decl);
        break;
      case "StructDecl":
        this.structChecker.registerStruct(
          decl,
          false,
          this.checkDuplicateTypeParams.bind(this),
          this.buildFunctionType.bind(this)
        );
        break;
      case "UnsafeStructDecl":
        this.structChecker.registerStruct(
          decl,
          true,
          this.checkDuplicateTypeParams.bind(this),
          this.buildFunctionType.bind(this)
        );
        break;
      case "EnumDecl":
        this.enumChecker.registerEnum(decl);
        break;
      case "TypeAlias":
        this.registerTypeAlias(decl);
        break;
      case "StaticDecl":
        this.registerStatic(decl);
        break;
      case "ImportDecl":
        this.registerImport(decl);
        break;
    }
  }

  /** Second pass: fully check declarations. */
  checkDeclaration(decl: Declaration): void {
    switch (decl.kind) {
      case "FunctionDecl":
        this.checkFunction(decl);
        break;
      case "ExternFunctionDecl":
        // Already registered, nothing else to check
        break;
      case "StructDecl":
        this.structChecker.checkStruct(decl, false);
        break;
      case "UnsafeStructDecl":
        this.structChecker.checkStruct(decl, true);
        break;
      case "EnumDecl":
        this.enumChecker.checkEnum(decl);
        break;
      case "TypeAlias":
        // Already registered
        break;
      case "StaticDecl":
        this.checkStaticDecl(decl);
        break;
      case "ImportDecl":
        // Already registered
        break;
    }
  }

  // ─── Auto-generate lifecycle hooks (Pass 1.5) ────────────────────────────

  autoGenerateDestroys(declarations: Declaration[]): void {
    this.structChecker.autoGenerateDestroys(declarations);
  }

  autoGenerateOncopies(declarations: Declaration[]): void {
    this.structChecker.autoGenerateOncopies(declarations);
  }

  // ─── Registration (Pass 1) ──────────────────────────────────────────────

  private registerFunction(decl: FunctionDecl): void {
    const funcType = this.buildFunctionType(decl);
    const sym = functionSymbol(decl.name, funcType, false, decl);
    if (!this.checker.currentScope.define(sym)) {
      this.checker.error(
        `duplicate declaration '${decl.name}' (same parameter signature)`,
        decl.span
      );
    }
  }

  private registerExternFunction(decl: ExternFunctionDecl): void {
    const params: ParamInfo[] = decl.params.map((p) => ({
      name: p.name,
      type: this.checker.resolveType(p.typeAnnotation),
      isMut: p.isMut,
      isMove: p.isMove,
    }));

    const returnType = decl.returnType ? this.checker.resolveType(decl.returnType) : VOID_TYPE;

    const funcType = functionType(params, returnType, [], [], true);
    const sym = functionSymbol(decl.name, funcType, true);
    if (!this.checker.currentScope.define(sym)) {
      this.checker.error(`duplicate declaration '${decl.name}'`, decl.span);
    }
  }

  private registerTypeAlias(decl: TypeAlias): void {
    const resolvedType = this.checker.resolveType(decl.typeValue);
    const sym = typeSymbol(decl.name, resolvedType);
    if (!this.checker.currentScope.define(sym)) {
      this.checker.error(`duplicate declaration '${decl.name}'`, decl.span);
    }
  }

  private registerStatic(decl: StaticDecl): void {
    // Static type will be checked in pass 2, register with placeholder
    const initType = decl.typeAnnotation
      ? this.checker.resolveType(decl.typeAnnotation)
      : this.inferStaticType(decl);

    const sym = variableSymbol(decl.name, initType, false, true);
    if (!this.checker.currentScope.define(sym)) {
      this.checker.error(`duplicate declaration '${decl.name}'`, decl.span);
    }
  }

  private registerImport(decl: ImportDecl): void {
    const moduleExports = this.checker.getModuleExports();
    const exportedSymbols = moduleExports.get(decl.path);

    if (!exportedSymbols) {
      // No module exports available — may be single-file mode or unresolved
      // Register placeholders for selective imports (backward compat)
      if (decl.items.length > 0) {
        for (const item of decl.items) {
          this.checker.currentScope.define(
            typeSymbol(item, {
              kind: TypeKind.Struct,
              name: item,
              fields: new Map(),
              methods: new Map(),
              isUnsafe: false,
              genericParams: [],
            })
          );
        }
      }
      return;
    }

    if (decl.items.length > 0) {
      // Selective import: import { add, multiply } from math;
      // Bring only the named items directly into scope
      for (const item of decl.items) {
        const sym = exportedSymbols.get(item);
        if (sym) {
          this.checker.currentScope.define(sym);
        } else {
          this.checker.error(`'${item}' is not exported by module '${decl.path}'`, decl.span);
        }
      }
    } else {
      // Whole-module import: import math;
      // Register as a module symbol for qualified access: math.add()
      const modExports = new Map<string, Type>();
      for (const [name, sym] of exportedSymbols) {
        modExports.set(name, sym.type);
      }

      // Use the last part of the dotted path as the local name
      const parts = decl.path.split(".");
      const localName = parts[parts.length - 1];

      const modType: ModuleType = {
        kind: TypeKind.Module,
        name: decl.path,
        exports: modExports,
      };

      this.checker.currentScope.define(moduleSymbol(localName, modType, exportedSymbols));
    }
  }

  // ─── Full Checking (Pass 2) ─────────────────────────────────────────────

  private checkFunction(decl: FunctionDecl): void {
    // Skip body checking for generic functions — they are checked when instantiated
    if (decl.genericParams.length > 0) return;

    const funcSym = this.checker.currentScope.lookupFunction(decl.name);
    if (!funcSym || funcSym.kind !== "function") return;

    // Find the overload matching this specific declaration
    const overload = funcSym.overloads.find((o) => o.declaration === decl);
    const funcType = overload ? overload.type : funcSym.type;

    // Create function scope
    this.checker.pushScope({ functionContext: funcType });

    // Add params to scope
    for (const param of decl.params) {
      const paramType = this.checker.resolveType(param.typeAnnotation);
      this.checker.defineVariable(param.name, paramType, param.isMut, false, param.span);
    }

    // Check body
    let returns = false;
    for (const stmt of decl.body.statements) {
      if (returns) {
        this.checker.warning("unreachable code after return", stmt.span);
        break;
      }
      returns = this.checker.checkStatement(stmt);
    }

    // Check all code paths return
    if (funcType.returnType.kind !== TypeKind.Void && !returns) {
      this.checker.error(`function '${decl.name}' does not return a value on all paths`, decl.span);
    }

    this.checker.popScope();
  }

  private checkStaticDecl(decl: StaticDecl): void {
    const initType = this.checker.checkExpression(decl.initializer);

    if (decl.typeAnnotation) {
      const annotatedType = this.checker.resolveType(decl.typeAnnotation);
      if (
        !isErrorType(initType) &&
        !isErrorType(annotatedType) &&
        !isAssignableTo(initType, annotatedType)
      ) {
        this.checker.error(
          `type mismatch: expected '${typeToString(annotatedType)}', got '${typeToString(initType)}'`,
          decl.span
        );
      }
    }
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  private buildFunctionType(decl: FunctionDecl): FunctionType {
    // Check for duplicate type parameters
    this.checkDuplicateTypeParams(decl.genericParams, decl.name, decl.span);

    // Push generic type params into scope for resolving param/return types
    if (decl.genericParams.length > 0) {
      this.checker.pushScope({});
      for (const gp of decl.genericParams) {
        this.checker.currentScope.define(typeSymbol(gp, { kind: TypeKind.TypeParam, name: gp }));
      }
    }

    const params: ParamInfo[] = decl.params.map((p) => ({
      name: p.name,
      type: this.checker.resolveType(p.typeAnnotation),
      isMut: p.isMut,
      isMove: p.isMove,
    }));

    const returnType = decl.returnType ? this.checker.resolveType(decl.returnType) : VOID_TYPE;

    const throwsTypes = decl.throwsTypes.map((t) => this.checker.resolveType(t));

    if (decl.genericParams.length > 0) {
      this.checker.popScope();
    }

    return functionType(params, returnType, throwsTypes, decl.genericParams, false);
  }

  /** Report an error if the same type parameter name appears more than once. */
  private checkDuplicateTypeParams(
    params: string[],
    declName: string,
    span: { start: number; end: number }
  ): void {
    const seen = new Set<string>();
    for (const gp of params) {
      if (seen.has(gp)) {
        this.checker.error(`duplicate type parameter '${gp}' in '${declName}'`, span);
      }
      seen.add(gp);
    }
  }

  private inferStaticType(decl: StaticDecl): Type {
    // Simple inference for static: check literal type
    switch (decl.initializer.kind) {
      case "IntLiteral":
        return I32_TYPE;
      case "FloatLiteral":
        return { kind: TypeKind.Float, bits: 64 };
      case "StringLiteral":
        return { kind: TypeKind.String };
      case "BoolLiteral":
        return { kind: TypeKind.Bool };
      default:
        return ERROR_TYPE;
    }
  }
}
