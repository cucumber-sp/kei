/**
 * Type-checks struct and unsafe struct declarations, including
 * lifecycle hook auto-generation (__destroy / __oncopy).
 */

import type { Declaration, FunctionDecl, StructDecl, UnsafeStructDecl } from "../ast/nodes.ts";
import type { Checker } from "./checker.ts";
import { typeSymbol } from "./symbols.ts";
import type { FunctionType, ParamInfo, StructType } from "./types";
import { functionType, isPtrType, TypeKind, VOID_TYPE } from "./types";

export class StructChecker {
  private checker: Checker;

  constructor(checker: Checker) {
    this.checker = checker;
  }

  // ─── Registration (Pass 1) ──────────────────────────────────────────────

  registerStruct(
    decl: StructDecl | UnsafeStructDecl,
    isUnsafe: boolean,
    checkDuplicateTypeParams: (
      params: string[],
      declName: string,
      span: { start: number; end: number }
    ) => void,
    buildFunctionType: (decl: FunctionDecl) => FunctionType
  ): void {
    // Check for duplicate type parameters
    checkDuplicateTypeParams(decl.genericParams, decl.name, decl.span);

    // Create the struct type first with empty fields/methods so self-references work
    const structType: StructType = {
      kind: TypeKind.Struct,
      name: decl.name,
      fields: new Map(),
      methods: new Map(),
      isUnsafe,
      genericParams: decl.genericParams,
    };

    // Register early so self-referencing types in methods/fields resolve
    const sym = typeSymbol(decl.name, structType, decl);
    if (!this.checker.currentScope.define(sym)) {
      this.checker.error(`duplicate declaration '${decl.name}'`, decl.span);
      return;
    }

    // Register generic type params temporarily in scope for field/method resolution
    if (decl.genericParams.length > 0) {
      this.checker.pushScope({});
      for (const gp of decl.genericParams) {
        this.checker.currentScope.define(typeSymbol(gp, { kind: TypeKind.TypeParam, name: gp }));
      }
    }

    // Now resolve fields
    const fieldNames = new Set<string>();
    for (const field of decl.fields) {
      if (fieldNames.has(field.name)) {
        this.checker.error(`duplicate field '${field.name}' in struct '${decl.name}'`, field.span);
        continue;
      }
      fieldNames.add(field.name);
      const fieldType = this.checker.resolveType(field.typeAnnotation);
      structType.fields.set(field.name, fieldType);
    }

    // Now resolve methods (self: StructName will now resolve)
    const seenMethods = new Set<string>();
    for (const method of decl.methods) {
      if (seenMethods.has(method.name)) {
        this.checker.error(
          `duplicate method '${method.name}' in struct '${decl.name}'`,
          method.span
        );
        continue;
      }
      seenMethods.add(method.name);
      const methodType = buildFunctionType(method);
      structType.methods.set(method.name, methodType);
    }

    if (decl.genericParams.length > 0) {
      this.checker.popScope();
    }
  }

  // ─── Auto-generate __destroy (Pass 1.5) ─────────────────────────────────

  /**
   * After all structs are registered (pass 1), auto-generate __destroy for
   * any regular struct that has managed fields (string or struct-with-destroy)
   * but no explicit __destroy method. Uses fixed-point iteration to handle
   * nested structs (struct A has field of struct B which has a string field).
   */
  autoGenerateDestroys(declarations: Declaration[]): void {
    // Collect all struct type symbols
    const structDecls = declarations.filter(
      (d): d is StructDecl | UnsafeStructDecl =>
        d.kind === "StructDecl" || d.kind === "UnsafeStructDecl"
    );

    // Fixed-point: keep iterating until no new __destroy methods are added
    let changed = true;
    while (changed) {
      changed = false;
      for (const decl of structDecls) {
        // Skip generic structs — handled at monomorphization time
        if (decl.genericParams.length > 0) continue;

        const typeSym = this.checker.currentScope.lookupType(decl.name);
        if (!typeSym || typeSym.kind !== "type" || typeSym.type.kind !== TypeKind.Struct) continue;

        const structType = typeSym.type;

        // Skip if already has __destroy (explicit or auto-generated)
        if (structType.methods.has("__destroy")) continue;

        // Check if any field needs destruction
        if (this.hasManagedFields(structType)) {
          // Synthesize a __destroy method type: fn __destroy(self: StructName) -> void
          const destroyType = functionType(
            [{ name: "self", type: structType, isMut: false, isMove: false }],
            VOID_TYPE,
            [],
            [],
            false
          );
          structType.methods.set("__destroy", destroyType);
          structType.autoDestroy = true;
          changed = true;
        }
      }
    }
  }

  /**
   * After auto __destroy generation, auto-generate __oncopy for any struct
   * that has managed fields (string or struct-with-oncopy) but no explicit
   * __oncopy method. Uses fixed-point iteration like autoGenerateDestroys.
   */
  autoGenerateOncopies(declarations: Declaration[]): void {
    const structDecls = declarations.filter(
      (d): d is StructDecl | UnsafeStructDecl =>
        d.kind === "StructDecl" || d.kind === "UnsafeStructDecl"
    );

    let changed = true;
    while (changed) {
      changed = false;
      for (const decl of structDecls) {
        if (decl.genericParams.length > 0) continue;

        const typeSym = this.checker.currentScope.lookupType(decl.name);
        if (!typeSym || typeSym.kind !== "type" || typeSym.type.kind !== TypeKind.Struct) continue;

        const structType = typeSym.type;

        if (structType.methods.has("__oncopy")) continue;

        if (this.hasCopyableFields(structType)) {
          // Synthesize __oncopy: fn __oncopy(self: StructName) -> StructName
          const oncopyType = functionType(
            [{ name: "self", type: structType, isMut: false, isMove: false }],
            structType,
            [],
            [],
            false
          );
          structType.methods.set("__oncopy", oncopyType);
          structType.autoOncopy = true;
          changed = true;
        }
      }
    }
  }

  // ─── Full Checking (Pass 2) ─────────────────────────────────────────────

  checkStruct(decl: StructDecl | UnsafeStructDecl, isUnsafe: boolean): void {
    // Skip body checking for generic structs — methods are checked when instantiated
    if (decl.genericParams.length > 0) return;

    // Regular structs cannot have ptr<T> fields — only unsafe struct allows them
    if (!isUnsafe) {
      for (const field of decl.fields) {
        const ft = this.checker.resolveType(field.typeAnnotation);
        if (isPtrType(ft)) {
          this.checker.error(
            `struct '${decl.name}' cannot have pointer field '${field.name}'; use 'unsafe struct' for pointer fields`,
            field.span
          );
        }
      }
    }

    // Check unsafe struct lifecycle rules
    if (isUnsafe) {
      const hasPtrField = decl.fields.some((f) => {
        const ft = this.checker.resolveType(f.typeAnnotation);
        return isPtrType(ft);
      });

      if (hasPtrField) {
        const hasDestroy = decl.methods.some((m) => m.name === "__destroy");
        const hasOncopy = decl.methods.some((m) => m.name === "__oncopy");

        if (!hasDestroy) {
          this.checker.error(
            `unsafe struct '${decl.name}' with ptr<T> fields must define '__destroy'`,
            decl.span
          );
        }
        if (!hasOncopy) {
          this.checker.error(
            `unsafe struct '${decl.name}' with ptr<T> fields must define '__oncopy'`,
            decl.span
          );
        }
      }
    }

    // Validate lifecycle hook signatures
    for (const method of decl.methods) {
      if (method.name === "__destroy") {
        if (method.params.length !== 1) {
          this.checker.error(
            `lifecycle hook '__destroy' must take exactly 1 parameter`,
            method.span
          );
        }
        if (method.returnType) {
          const retType = this.checker.resolveType(method.returnType);
          if (retType.kind !== TypeKind.Void) {
            this.checker.error(`lifecycle hook '__destroy' must return void`, method.span);
          }
        }
      } else if (method.name === "__oncopy") {
        if (method.params.length >= 1 && method.params[0].name !== "self") {
          this.checker.error(
            `lifecycle hook '__oncopy' first parameter must be named 'self'`,
            method.span
          );
        }
      }
    }

    // Check methods
    for (const method of decl.methods) {
      this.checkStructMethod(decl, method);
    }
  }

  private checkStructMethod(structDecl: StructDecl | UnsafeStructDecl, method: FunctionDecl): void {
    // Look up the struct's type symbol to get the StructType
    const typeSym = this.checker.currentScope.lookupType(structDecl.name);
    if (!typeSym || typeSym.kind !== "type" || typeSym.type.kind !== TypeKind.Struct) return;

    const structType = typeSym.type;
    const methodFuncType = structType.methods.get(method.name);
    if (!methodFuncType) return;

    // Create method scope
    this.checker.pushScope({ functionContext: methodFuncType });

    // Add generic type params
    for (const gp of structDecl.genericParams) {
      this.checker.currentScope.define(typeSymbol(gp, { kind: TypeKind.TypeParam, name: gp }));
    }
    for (const gp of method.genericParams) {
      this.checker.currentScope.define(typeSymbol(gp, { kind: TypeKind.TypeParam, name: gp }));
    }

    // Add params to scope
    for (const param of method.params) {
      const paramType = this.checker.resolveType(param.typeAnnotation);
      this.checker.defineVariable(param.name, paramType, param.isMut, false, param.span);
    }

    // Check body
    let returns = false;
    for (const stmt of method.body.statements) {
      if (returns) {
        this.checker.warning("unreachable code after return", stmt.span);
        break;
      }
      returns = this.checker.checkStatement(stmt);
    }

    if (methodFuncType.returnType.kind !== TypeKind.Void && !returns) {
      this.checker.error(
        `method '${method.name}' does not return a value on all paths`,
        method.span
      );
    }

    this.checker.popScope();
  }

  // ─── Helpers ───────────────────────────────────────────────────────────

  /** Check if a struct type has any fields that need copy hooks (string or struct with __oncopy). */
  private hasCopyableFields(structType: StructType): boolean {
    for (const [_name, fieldType] of structType.fields) {
      if (fieldType.kind === TypeKind.String) return true;
      if (fieldType.kind === TypeKind.Struct && fieldType.methods.has("__oncopy")) return true;
    }
    return false;
  }

  /** Check if a struct type has any fields that require destruction. */
  private hasManagedFields(structType: StructType): boolean {
    for (const [_name, fieldType] of structType.fields) {
      if (fieldType.kind === TypeKind.String) return true;
      if (fieldType.kind === TypeKind.Struct && fieldType.methods.has("__destroy")) return true;
    }
    return false;
  }
}
