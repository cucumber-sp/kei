/**
 * KIR → C code emitter.
 *
 * Takes a de-SSA'd KirModule and produces a string of valid C code.
 * Expects phi nodes to have already been eliminated by the de-SSA pass.
 */

import { readFileSync } from "node:fs";
import { dirname, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import type { KirModule } from "../kir/kir-types.ts";
import { emitExtern, emitFunctionPrototype, emitGlobal, emitTypeDecl } from "./c-emitter-decls.ts";
import { emitFunction } from "./c-emitter-fn.ts";
import { sanitizeName } from "./c-emitter-types.ts";

// ─── Runtime header (loaded from file) ──────────────────────────────────────

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const RUNTIME_HEADER_PATH = resolve(__dirname, "../runtime/runtime.h");
const RUNTIME_HEADER = `/* Generated by the Kei compiler */\n${readFileSync(RUNTIME_HEADER_PATH, "utf-8")}`;

// ─── Main emitter ───────────────────────────────────────────────────────────

export function emitC(module: KirModule): string {
  const out: string[] = [];

  out.push(RUNTIME_HEADER);

  // Forward-declare structs
  for (const td of module.types) {
    if (td.type.kind === "struct") {
      out.push(`struct ${sanitizeName(td.name)};`);
    }
  }
  if (module.types.length > 0) out.push("");

  // Type definitions
  for (const td of module.types) {
    out.push(emitTypeDecl(td));
    out.push("");
  }

  // Extern declarations
  for (const ext of module.externs) {
    out.push(emitExtern(ext));
  }
  if (module.externs.length > 0) out.push("");

  // Forward-declare all functions
  for (const fn of module.functions) {
    out.push(`${emitFunctionPrototype(fn)};`);
  }
  if (module.functions.length > 0) out.push("");

  // Global variables
  for (const g of module.globals) {
    out.push(emitGlobal(g));
  }
  if (module.globals.length > 0) out.push("");

  // Function definitions
  for (const fn of module.functions) {
    out.push(emitFunction(fn));
    out.push("");
  }

  return out.join("\n");
}
