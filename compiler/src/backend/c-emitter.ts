/**
 * KIR → C code emitter.
 *
 * Takes a de-SSA'd KirModule and produces a string of valid C code.
 * Expects phi nodes to have already been eliminated by the de-SSA pass.
 */

import type {
  KirModule,
  KirFunction,
  KirBlock,
  KirInst,
  KirTerminator,
  KirType,
  KirTypeDecl,
  KirExtern,
  KirGlobal,
  KirParam,
  VarId,
  BinOp,
} from "../kir/kir-types.ts";

// ─── Runtime header (inlined) ───────────────────────────────────────────────

const RUNTIME_HEADER = `/* Generated by the Kei compiler */
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

typedef const char* kei_string;

static void kei_panic(const char* msg) {
    fprintf(stderr, "panic: %s\\n", msg);
    exit(1);
}

static void kei_bounds_check(int64_t index, int64_t length) {
    if (index < 0 || index >= length) {
        fprintf(stderr, "panic: index out of bounds: index %lld, length %lld\\n",
                (long long)index, (long long)length);
        exit(1);
    }
}

static void kei_null_check(const void* ptr) {
    if (ptr == NULL) {
        kei_panic("null pointer dereference");
    }
}

static void kei_assert(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "assertion failed: %s\\n", msg);
        exit(1);
    }
}

static void kei_require(bool cond, const char* msg) {
    if (!cond) {
        fprintf(stderr, "requirement failed: %s\\n", msg);
        exit(1);
    }
}
`;

const IO_PRINT_HELPERS = `static void kei_print_string(kei_string s) {
    printf("%s\\n", s);
}

static void kei_print_int(int64_t v) {
    printf("%lld\\n", (long long)v);
}

static void kei_print_float(double v) {
    printf("%g\\n", v);
}

static void kei_print_bool(bool v) {
    printf("%s\\n", v ? "true" : "false");
}
`;

// ─── Type mapping ───────────────────────────────────────────────────────────

function emitCType(t: KirType): string {
  switch (t.kind) {
    case "int": {
      if (t.signed) {
        return `int${t.bits}_t`;
      }
      return `uint${t.bits}_t`;
    }
    case "float":
      return t.bits === 32 ? "float" : "double";
    case "bool":
      return "bool";
    case "void":
      return "void";
    case "string":
      return "kei_string";
    case "ptr":
      return `${emitCType(t.pointee)}*`;
    case "struct":
      return `struct ${sanitizeName(t.name)}`;
    case "enum":
      return `enum ${sanitizeName(t.name)}`;
    case "array":
      // Arrays in C can't be directly typed like this in all positions,
      // but for local variables we'll use the element type and declare with size
      return `${emitCType(t.element)}`;
    case "function":
      // Function types used as values — use void* for now
      return "void*";
  }
}

function emitCTypeForDecl(t: KirType, varName: string): string {
  if (t.kind === "array") {
    return `${emitCType(t.element)} ${varName}[${t.length}]`;
  }
  return `${emitCType(t)} ${varName}`;
}

/** Sanitize a name for use as a C identifier */
function sanitizeName(name: string): string {
  // Replace characters that aren't valid in C identifiers
  return name.replace(/[^a-zA-Z0-9_]/g, "_");
}

/** Convert a VarId like "%0" or "%x.1" to a C variable name */
function varName(v: VarId): string {
  if (v === "undef") return "0 /* undef */";
  // Strip the % prefix and sanitize
  const stripped = v.startsWith("%") ? v.slice(1) : v;
  return `_v${sanitizeName(stripped)}`;
}

// ─── Main emitter ───────────────────────────────────────────────────────────

/** Check if a function name is a std module intrinsic stub (no C definition needed) */
function isStdModuleStub(name: string): boolean {
  // io module print stubs
  if (name === "io_print_string" || name === "io_print_i32" || name === "io_print_i64"
    || name === "io_print_f64" || name === "io_print_f32" || name === "io_print_bool") return true;
  // mem module alloc/free stubs
  if (name === "mem_alloc" || name === "mem_free") return true;
  return false;
}

// Backward compat alias
const isIoPrintStub = isStdModuleStub;

/** Check if any function in the module calls an io_print_* intrinsic */
function usesIoPrint(module: KirModule): boolean {
  for (const fn of module.functions) {
    for (const block of fn.blocks) {
      for (const inst of block.instructions) {
        if ((inst.kind === "call" || inst.kind === "call_void") && isPrintIntrinsic(inst.func)) {
          return true;
        }
      }
    }
  }
  return false;
}

/** Check if a call target is an io module print intrinsic */
function isPrintIntrinsic(func: string): boolean {
  return func === "io_print_string" || func === "io_print_i32" || func === "io_print_i64"
    || func === "io_print_f64" || func === "io_print_f32" || func === "io_print_bool"
    // Also match direct-import forms (no io_ prefix, but mangled)
    || func === "print_string" || func === "print_i32" || func === "print_i64"
    || func === "print_f64" || func === "print_f32" || func === "print_bool";
}

export function emitC(module: KirModule): string {
  const out: string[] = [];

  out.push(RUNTIME_HEADER);

  // Emit print helpers only when io module print is used
  if (usesIoPrint(module)) {
    out.push(IO_PRINT_HELPERS);
  }

  // Forward-declare structs
  for (const td of module.types) {
    if (td.type.kind === "struct") {
      out.push(`struct ${sanitizeName(td.name)};`);
    }
  }
  if (module.types.length > 0) out.push("");

  // Type definitions
  for (const td of module.types) {
    out.push(emitTypeDecl(td));
    out.push("");
  }

  // Extern declarations
  for (const ext of module.externs) {
    out.push(emitExtern(ext));
  }
  if (module.externs.length > 0) out.push("");

  // Forward-declare all functions (skip io module print stubs)
  for (const fn of module.functions) {
    if (isIoPrintStub(fn.name)) continue;
    out.push(emitFunctionPrototype(fn) + ";");
  }
  if (module.functions.length > 0) out.push("");

  // Global variables
  for (const g of module.globals) {
    out.push(emitGlobal(g));
  }
  if (module.globals.length > 0) out.push("");

  // Function definitions (skip io module print stubs — they are intrinsics)
  for (const fn of module.functions) {
    if (isIoPrintStub(fn.name)) continue;
    out.push(emitFunction(fn));
    out.push("");
  }

  return out.join("\n");
}

// ─── Type declarations ──────────────────────────────────────────────────────

function emitTypeDecl(td: KirTypeDecl): string {
  if (td.type.kind === "struct") {
    const fields = td.type.fields
      .map((f) => `    ${emitCTypeForDecl(f.type, sanitizeName(f.name))};`)
      .join("\n");
    return `struct ${sanitizeName(td.name)} {\n${fields}\n};`;
  }
  if (td.type.kind === "enum") {
    // Simple C enum for variants with integer values
    const variants = td.type.variants
      .map((v) => {
        const name = `${sanitizeName(td.name)}_${sanitizeName(v.name)}`;
        if (v.value !== null) return `    ${name} = ${v.value}`;
        return `    ${name}`;
      })
      .join(",\n");
    return `enum ${sanitizeName(td.name)} {\n${variants}\n};`;
  }
  return `/* unknown type ${td.name} */`;
}

// ─── Extern declarations ────────────────────────────────────────────────────

function emitExtern(ext: KirExtern): string {
  const params = ext.params.map((p) => emitCType(p.type)).join(", ");
  return `extern ${emitCType(ext.returnType)} ${sanitizeName(ext.name)}(${params || "void"});`;
}

// ─── Globals ────────────────────────────────────────────────────────────────

function emitGlobal(g: KirGlobal): string {
  return `${emitCTypeForDecl(g.type, sanitizeName(g.name))};`;
}

// ─── Functions ──────────────────────────────────────────────────────────────

function emitFunctionPrototype(fn: KirFunction): string {
  const name = fn.name === "main" ? "main" : sanitizeName(fn.name);
  const retType = fn.name === "main" ? "int" : emitCType(fn.returnType);
  const params =
    fn.params.length === 0
      ? "void"
      : fn.params.map((p) => `${emitCType(p.type)} ${varName(p.name)}`).join(", ");
  return `${retType} ${name}(${params})`;
}

function emitFunction(fn: KirFunction): string {
  const out: string[] = [];
  out.push(emitFunctionPrototype(fn) + " {");

  // Collect all variables used in the function to declare them upfront
  const varDecls = collectVarDecls(fn);
  for (const [name, type] of varDecls) {
    out.push(`    ${emitCTypeForDecl(type, name)};`);
  }
  if (varDecls.size > 0) out.push("");

  // Emit blocks
  for (let i = 0; i < fn.blocks.length; i++) {
    const block = fn.blocks[i];
    // Skip label for entry block if it's the first block
    if (i > 0) {
      out.push(`${sanitizeName(block.id)}:`);
    } else {
      // Still emit label for entry block — other blocks might jump to it
      out.push(`${sanitizeName(block.id)}: ;`);
    }

    for (const inst of block.instructions) {
      const line = emitInst(inst);
      if (line) out.push(`    ${line}`);
    }

    const term = emitTerminator(block.terminator);
    if (term) out.push(`    ${term}`);
  }

  out.push("}");
  return out.join("\n");
}

// ─── Variable collection ────────────────────────────────────────────────────

function collectVarDecls(fn: KirFunction): Map<string, KirType> {
  const decls = new Map<string, KirType>();

  // Don't re-declare params
  const paramNames = new Set(fn.params.map((p) => varName(p.name)));

  for (const block of fn.blocks) {
    for (const inst of block.instructions) {
      // For stack_alloc, also declare backing storage variable
      if (inst.kind === "stack_alloc") {
        const allocName = `${varName(inst.dest)}_alloc`;
        decls.set(allocName, inst.type);
      }
      const dest = getInstDest(inst);
      const type = getInstType(inst);
      if (dest && type && !paramNames.has(varName(dest))) {
        decls.set(varName(dest), type);
      }
    }
  }

  return decls;
}

function getInstDest(inst: KirInst): VarId | null {
  switch (inst.kind) {
    case "stack_alloc":
    case "load":
    case "field_ptr":
    case "index_ptr":
    case "bin_op":
    case "neg":
    case "not":
    case "bit_not":
    case "const_int":
    case "const_float":
    case "const_bool":
    case "const_string":
    case "const_null":
    case "call":
    case "call_extern":
    case "cast":
    case "sizeof":
    case "move":
      return inst.dest;
    default:
      return null;
  }
}

function getInstType(inst: KirInst): KirType | null {
  switch (inst.kind) {
    case "stack_alloc":
      return { kind: "ptr", pointee: inst.type };
    case "load":
      return inst.type;
    case "field_ptr":
      return { kind: "ptr", pointee: inst.type };
    case "index_ptr":
      return { kind: "ptr", pointee: inst.type };
    case "bin_op":
      return inst.type;
    case "neg":
      return inst.type;
    case "not":
      return { kind: "bool" };
    case "bit_not":
      return inst.type;
    case "const_int":
      return inst.type;
    case "const_float":
      return inst.type;
    case "const_bool":
      return { kind: "bool" };
    case "const_string":
      return { kind: "string" };
    case "const_null":
      return inst.type;
    case "call":
      return inst.type;
    case "call_extern":
      return inst.type;
    case "cast":
      return inst.targetType;
    case "sizeof":
      return { kind: "int", bits: 64, signed: false };
    case "move":
      return inst.type;
    default:
      return null;
  }
}

// ─── C string escaping ──────────────────────────────────────────────────────

function cStringLiteral(s: string): string {
  let out = '"';
  for (let i = 0; i < s.length; i++) {
    const ch = s[i];
    const code = s.charCodeAt(i);
    switch (ch) {
      case '"': out += '\\"'; break;
      case '\\': out += '\\\\'; break;
      case '\n': out += '\\n'; break;
      case '\r': out += '\\r'; break;
      case '\t': out += '\\t'; break;
      case '\0': out += '\\0'; break;
      default:
        if (code < 0x20 || code > 0x7e) {
          // Use octal escape for non-printable chars (safe in C)
          out += '\\' + code.toString(8).padStart(3, '0');
        } else {
          out += ch;
        }
    }
  }
  out += '"';
  return out;
}

// ─── Instruction emission ───────────────────────────────────────────────────

function emitInst(inst: KirInst): string {
  switch (inst.kind) {
    case "stack_alloc": {
      // Allocate local — backing storage is declared at the top as _vN_alloc,
      // and the pointer variable _vN is set to its address
      return `${varName(inst.dest)} = &${varName(inst.dest)}_alloc;`;
    }
    case "load":
      return `${varName(inst.dest)} = *${varName(inst.ptr)};`;
    case "store":
      return `*${varName(inst.ptr)} = ${varName(inst.value)};`;
    case "field_ptr":
      return `${varName(inst.dest)} = &${varName(inst.base)}->${sanitizeName(inst.field)};`;
    case "index_ptr":
      return `${varName(inst.dest)} = &${varName(inst.base)}[${varName(inst.index)}];`;
    case "bin_op":
      return emitBinOp(inst.dest, inst.op, inst.lhs, inst.rhs);
    case "neg":
      return `${varName(inst.dest)} = -${varName(inst.operand)};`;
    case "not":
      return `${varName(inst.dest)} = !${varName(inst.operand)};`;
    case "bit_not":
      return `${varName(inst.dest)} = ~${varName(inst.operand)};`;
    case "const_int": {
      const val = inst.value;
      const cType = emitCType(inst.type);
      // Small signed values that fit in a plain int literal need no suffix
      if (inst.type.signed && val >= -2147483648 && val <= 2147483647) {
        return `${varName(inst.dest)} = ${val};`;
      }
      // Large or unsigned values: use LL/ULL suffix with explicit cast
      const suffix = inst.type.signed ? "LL" : "ULL";
      return `${varName(inst.dest)} = (${cType})${val}${suffix};`;
    }
    case "const_float":
      return `${varName(inst.dest)} = ${inst.value};`;
    case "const_bool":
      return `${varName(inst.dest)} = ${inst.value ? "true" : "false"};`;
    case "const_string":
      return `${varName(inst.dest)} = ${cStringLiteral(inst.value)};`;
    case "const_null":
      return `${varName(inst.dest)} = NULL;`;
    case "call":
      return `${varName(inst.dest)} = ${emitCallTarget(inst.func)}(${inst.args.map(varName).join(", ")});`;
    case "call_void":
      return `${emitCallTarget(inst.func)}(${inst.args.map(varName).join(", ")});`;
    case "call_extern":
      return `${varName(inst.dest)} = ${sanitizeName(inst.func)}(${inst.args.map(varName).join(", ")});`;
    case "call_extern_void":
      return `${sanitizeName(inst.func)}(${inst.args.map(varName).join(", ")});`;
    case "cast":
      return `${varName(inst.dest)} = (${emitCType(inst.targetType)})${varName(inst.value)};`;
    case "sizeof":
      return `${varName(inst.dest)} = sizeof(${emitCType(inst.type)});`;
    case "bounds_check":
      return `kei_bounds_check((int64_t)${varName(inst.index)}, (int64_t)${varName(inst.length)});`;
    case "overflow_check":
      return `/* overflow_check ${inst.op} ${varName(inst.lhs)} ${varName(inst.rhs)} */`;
    case "null_check":
      return `kei_null_check(${varName(inst.ptr)});`;
    case "assert_check":
      return `kei_assert(${varName(inst.cond)}, ${cStringLiteral(inst.message)});`;
    case "require_check":
      return `kei_require(${varName(inst.cond)}, ${cStringLiteral(inst.message)});`;
    case "destroy":
      return `${sanitizeName(inst.structName)}___destroy(${varName(inst.value)});`;
    case "oncopy":
      return `${varName(inst.value)} = ${sanitizeName(inst.structName)}___oncopy(${varName(inst.value)});`;
    case "move":
      return `${varName(inst.dest)} = ${varName(inst.source)};`;
  }
}

function emitCallTarget(func: string): string {
  // Map io module print intrinsics to C runtime functions
  // Handles both io_print_* (whole-module import) and print_* (selective import)
  if (func === "io_print_string" || func === "print_string") return "kei_print_string";
  if (func === "io_print_i32" || func === "print_i32") return "kei_print_int";
  if (func === "io_print_i64" || func === "print_i64") return "kei_print_int";
  if (func === "io_print_f64" || func === "print_f64") return "kei_print_float";
  if (func === "io_print_f32" || func === "print_f32") return "kei_print_float";
  if (func === "io_print_bool" || func === "print_bool") return "kei_print_bool";
  // mem module alloc/free intrinsics
  if (func === "mem_alloc" || func === "alloc") return "malloc";
  if (func === "mem_free" || func === "free") return "free";
  return sanitizeName(func);
}

function emitBinOp(dest: VarId, op: BinOp, lhs: VarId, rhs: VarId): string {
  const d = varName(dest);
  const l = varName(lhs);
  const r = varName(rhs);

  const cOp = binOpToC(op);
  return `${d} = ${l} ${cOp} ${r};`;
}

function binOpToC(op: BinOp): string {
  switch (op) {
    case "add": return "+";
    case "sub": return "-";
    case "mul": return "*";
    case "div": return "/";
    case "mod": return "%";
    case "eq": return "==";
    case "neq": return "!=";
    case "lt": return "<";
    case "gt": return ">";
    case "lte": return "<=";
    case "gte": return ">=";
    case "and": return "&&";
    case "or": return "||";
    case "bit_and": return "&";
    case "bit_or": return "|";
    case "bit_xor": return "^";
    case "shl": return "<<";
    case "shr": return ">>";
  }
}

// ─── Terminator emission ────────────────────────────────────────────────────

function emitTerminator(term: KirTerminator): string {
  switch (term.kind) {
    case "ret":
      return `return ${varName(term.value)};`;
    case "ret_void":
      return "return;";
    case "jump":
      return `goto ${sanitizeName(term.target)};`;
    case "br":
      return `if (${varName(term.cond)}) goto ${sanitizeName(term.thenBlock)}; else goto ${sanitizeName(term.elseBlock)};`;
    case "switch": {
      const lines = [`switch (${varName(term.value)}) {`];
      for (const c of term.cases) {
        lines.push(`        case ${varName(c.value)}: goto ${sanitizeName(c.target)};`);
      }
      lines.push(`        default: goto ${sanitizeName(term.defaultBlock)};`);
      lines.push("    }");
      return lines.join("\n");
    }
    case "unreachable":
      return `__builtin_unreachable();`;
  }
}
